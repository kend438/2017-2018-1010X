#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    Arm,            sensorNone)
#pragma config(Sensor, in2,    ClawP,          sensorPotentiometer)
#pragma config(Sensor, in3,    ,               sensorPotentiometer)
#pragma config(Sensor, in4,    GyroSensor,     sensorGyro)
#pragma config(Sensor, dgtl1,  RightSensor,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  LeftSensor,     sensorQuadEncoder)
#pragma config(Motor,  port1,           BackLeft,      tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           FrontRight,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           ArmRight1,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           ArmRight2,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           ClawRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           ClawLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           ArmLeft2,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           ArmLeft1,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           FrontLeft,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          BackRight,     tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int LSensor;
int RSensor;
int ArmSensor;
int ClawSensor;
int Gyro;

int PosArmUp;
int PosClawClosed;
int PosArmDown;
int PosClawWide;
int PosClawFolded;
int ClawStop;
int Auto;
int Confirm;

void SensorUpdate(){
	LSensor=SensorValue[LeftSensor];
	RSensor=-SensorValue[RightSensor];
	ClawSensor=SensorValue[ClawP]-410;
	ArmSensor=SensorValue[Arm]-920;
	Gyro=-SensorValue[GyroSensor];
}
//LCD Buttons
void LCDUpdate(){
	if(nLCDButtons==1){
		Auto=Auto-1;
		wait(0.2);
	}
	if(nLCDButtons==4){
		Auto=Auto+1;
		wait(0.2);
	}
	if(Auto==8){
		Auto=1;
	}
	if(Auto==0){
		Auto=7;
	}
	if(nLCDButtons==2){
		Confirm=1;
		displayLCDString(1,0,"   Confirmed    ");
		wait(1);
	}
	//LCD Display

	if(Auto==1){
		displayLCDString(0,0,"     Skills     ");
	}
	if(Auto==2){
		displayLCDString(0,0,"  Left Center   ");
	}
	if(Auto==3){
		displayLCDString(0,0,"  Right Center  ");
	}
	if(Auto==4){
		displayLCDString(0,0,"  Left Corner   ");
	}
	if(Auto==5){
		displayLCDString(0,0,"  Right Corner  ");
	}
	if(Auto==6){
		displayLCDString(0,0,"   Left Cube    ");
	}
	if(Auto==7){
		displayLCDString(0,0,"   Right Cube   ");
	}
}
void SensorReset(){
	SensorValue[LeftSensor]=0;
	SensorValue[RightSensor]=0;
	LSensor=0;
	RSensor=0;
	Gyro=0;
	SensorValue[GyroSensor] = 0;
}

void Forward(){
	SensorUpdate();
	setMultipleMotors(100,FrontLeft,FrontRight,BackLeft,BackRight);
}

void Drive(int x){
	if(x>0){

		while(LSensor<x){
			setMultipleMotors(100,FrontLeft,FrontRight,BackLeft,BackRight);
			SensorUpdate();
		}
		SensorReset();
		stopAllMotors();
	}
	else{
		while(LSensor>x){
			setMultipleMotors(-100,FrontLeft,FrontRight,BackLeft,BackRight);
			SensorUpdate();
		}
		SensorReset();
		stopAllMotors();
	}
}

void Turn(int x){
	if(x>0){
		while(Gyro<x){
			setMultipleMotors(100,FrontLeft,BackLeft);
			setMultipleMotors(-100,FrontRight,BackRight);
			SensorUpdate();
		}
		SensorReset();
		stopAllMotors();
	}
	else{
		while(Gyro>x){
			setMultipleMotors(-100,FrontLeft,BackLeft);
			setMultipleMotors(100,FrontRight,BackRight);
			SensorUpdate();
		}
		SensorReset();
		stopAllMotors();
	}
}

void MoveArm(int x){
	if(x>ArmSensor){

		while(ArmSensor<x){
			SensorUpdate();
			setMultipleMotors(100,ArmLeft1,ArmLeft2);
			setMultipleMotors(100,ArmRight1,ArmRight2);
		}
		SensorReset();
		stopAllMotors();
	}
	else{
		while(ArmSensor>x){
			SensorUpdate();
			setMultipleMotors(-100,ArmLeft1,ArmLeft2);
			setMultipleMotors(-100,ArmRight1,ArmRight2);
		}
		SensorReset();
		stopAllMotors();
	}
}

void Claw(int x){
	if(x>ClawSensor){

		while(ClawSensor<x){
			SensorUpdate();
			setMotor(ClawLeft,100);
			setMotor(ClawRight,100);
		}
		SensorReset();
		stopAllMotors();
	}
	else{
		while(ClawSensor>x){
			SensorUpdate();
			setMotor(ClawLeft,-100);
			setMotor(ClawRight,-100);
		}
		SensorReset();
		stopAllMotors();
	}
}
void ClawHold(){
	SensorUpdate();
	setMultipleMotors(-10,ClawLeft,ClawRight);
}

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

void pre_auton()
{
	bLCDBacklight = true;
	bStopTasksBetweenModes = true;
	Auto=1;
	while(Confirm==0){
		LCDUpdate();
	}
}

task autonomous()
{
/*
	SensorReset();
	PosArmDown=0;
	PosArmUp=2100;
	PosClawClosed=3050;
	PosClawWide=1550;
	PosClawFolded=0;


	//up
	MoveArm(30);

	if(Auto==1||Auto==2||Auto==5||Auto==6){

		//out and up
		while(ClawSensor<300){
			ClawClose();
		}
		SensorReset();
		stopAllMotors();
	}
	else{
		//out and up
		while(ClawSensor<300){
			ClawClose();
		}
		SensorReset();
		stopAllMotors();
	}


	//arm up
	while(ArmSensor<700){
		ArmUp();
	}
	SensorReset();
	stopAllMotors();

	//LEFT CENTER 490
	//RIGHT CENTER 640
	//LEFT CORNER 785
	//RIGHT CORNER 910
	//LEFT CUBE 1030
	//RIGHT CUBE 1140

	//AUTO SKILLS

	if(Auto==1){
		//back
		Drive(-100);
		//claw closeish
		Claw(2000);
		//arm down
		MoveArm(0);
		//Drive into stars
		Drive(1500);
		//close claw
		Claw(2800);
		//up a bit
		MoveArm(200);
		//Drive back from stars
		Drive(-1500);
		//turn to fence
		Turn(-630);
		//arm up and drive
		MoveArm(2000);
		Forward();
		wait(1.5);
		stopAllMotors();
		//open claw
		Claw(1400);
		wait(0.5);
		//back up a bit
		Drive(-100);
		//claw closeish
		Claw(1800);
		//turn other stars
		Turn(660);
		//back up a bit
		Drive(-200);
		//arm down
		MoveArm(10);
		//pick up other stars
		Drive(2600);
		//close claw
		Claw(2900);
		//arm up
		MoveArm(2000);
		//turn to fence
		Turn(-630);
		//to fence
		Drive(100);
		//open claw
		Claw(1400);
		wait(0.5);
		//back up a bit
		Drive(-200);
		//180
		Turn(-1600);
		//arm down
		MoveArm(10);
		Backwards();
		wait(1);
		stopAllMotors();
		//to cube
		Drive(580);
		//grab cube
		Claw(2400);
		//pick up a bit
		MoveArm(700);
		//180
		Turn(1600);
		//arm up and forward
		MoveArm(2000);
		Forward();
		wait(2);
		stopAllMotors();
		//open claw at fence
		Claw(1400);
		wait(1);
		//back up a bit from fence
		while(LSensor>-200){
			Backwards();
		}
		SensorReset();
		stopAllMotors();

		//turn left to go back to start
		while(Gyro>-630){
			TurnLeft();
		}
		SensorReset();
		stopAllMotors();

		//drive across feild
		while(LSensor<2600){
			Forward();
		}
		SensorReset();
		stopAllMotors();

		//turn to manual loads
		while(Gyro>-630){
			TurnLeft();
		}
		SensorReset();
		stopAllMotors();

		//to manual loads
		while(Gyro>-1600){
			TurnLeft();
		}
		SensorReset();
		stopAllMotors();
	}
	//SKILLS END

	//LEFT CENTER
	if(Auto==2){

		//back
		while(LSensor>-100){
			Backwards();
		}
		SensorReset();
		stopAllMotors();

		//claw closeish
		while(LClawSensor<2000){
			ClawClose();
		}
		SensorReset();
		stopAllMotors();

		//arm down
		while(ArmSensor>0){
			ArmDown();
		}
		SensorReset();
		stopAllMotors();

		//Drive into stars
		while(LSensor<1500){
			Forward();
		}
		SensorReset();
		stopAllMotors();

		//close claw
		while(LClawSensor<3100){
			ClawClose();
		}
		SensorReset();
		stopAllMotors();

		//up a bit
		while(ArmSensor<200){
			ArmUp();
		}
		SensorReset();
		stopAllMotors();

		//Drive back from stars
		while(LSensor>-1200){
			Backwards();
		}
		SensorReset();
		stopAllMotors();

		//turn to fence
		while(Gyro>-630){
			TurnLeft();
		}
		SensorReset();
		stopAllMotors();

		//arm up and drive
		while(ArmSensor<2000){
			ArmUp();
			Forward();
		}
		SensorReset();
		stopAllMotors();

		Forward();
		wait(1.5);

		stopAllMotors();

		//open claw
		while(LClawSensor>1400){
			ClawOpen();
		}
		SensorReset();
		stopAllMotors();

		wait(0.5);

		//back from fence
		while(LSensor>-1000){
			Backwards();
		}
		SensorReset();
		stopAllMotors();

		//turn to cube
		while(LSensor<170){
			TurnRight();
		}
		SensorReset();
		stopAllMotors();

		//back away from cube
		while(LSensor>-500){
			Backwards();
		}
		SensorReset();
		stopAllMotors();

		//lower arm
		while(ArmSensor>0){
			ArmDown();
		}
		SensorReset();
		stopAllMotors();

		//to cube
		while(LSensor<1000){
			Forward();
		}
		SensorReset();
		stopAllMotors();
	}
	//LEFT CENTER END

	//RIGHT CENTER
	if(Auto==3){

		//back
		while(LSensor>-100){
			Backwards();
		}
		SensorReset();
		stopAllMotors();

		//claw closeish
		while(LClawSensor<2000){
			ClawClose();
		}
		SensorReset();
		stopAllMotors();

		//arm down
		while(ArmSensor>0){
			ArmDown();
		}
		SensorReset();
		stopAllMotors();

		//Drive into stars
		while(LSensor<1500){
			Forward();
		}
		SensorReset();
		stopAllMotors();

		//close claw
		while(RClawSensor<3100){
			ClawClose();
		}
		SensorReset();
		stopAllMotors();

		//up a bit
		while(ArmSensor<200){
			ArmUp();
		}
		SensorReset();
		stopAllMotors();

		//Drive back from stars
		while(LSensor>-1400){
			Backwards();
		}
		SensorReset();
		stopAllMotors();

		//turn to fence
		while(Gyro<630){
			TurnRight();
		}
		SensorReset();
		stopAllMotors();

		//arm up and drive
		while(ArmSensor<2000){
			ArmUp();
			Forward();
		}
		SensorReset();
		stopAllMotors();

		Forward();
		wait(1.5);

		stopAllMotors();

		//open claw
		while(LClawSensor>1400){
			ClawOpen();
		}
		SensorReset();
		stopAllMotors();

		wait(0.5);

		//back from fence
		while(LSensor>-1000){
			Backwards();
		}
		SensorReset();
		stopAllMotors();

		//turn to cube
		while(LSensor>-250){
			TurnLeft();
		}
		SensorReset();
		stopAllMotors();

		//back away from cube
		while(LSensor>-500){
			Backwards();
		}
		SensorReset();
		stopAllMotors();

		//lower arm
		while(ArmSensor>0){
			ArmDown();
		}
		SensorReset();
		stopAllMotors();

		//to cube
		while(LSensor<1000){
			Forward();
		}
		SensorReset();
		stopAllMotors();
	}

	//LEFT CORNER
	if(Auto==4){

		//back
		while(LSensor>-100){
			Backwards();
		}
		SensorReset();
		stopAllMotors();

		//claw closeish
		while(LClawSensor<2000){
			ClawClose();
		}
		SensorReset();
		stopAllMotors();

		//arm down
		while(ArmSensor>0){
			ArmDown();
		}
		SensorReset();
		stopAllMotors();

		//Drive into stars
		while(LSensor<450){
			Forward();
		}
		SensorReset();
		stopAllMotors();

		//close claw
		while(LClawSensor<2900){
			ClawClose();
		}
		SensorReset();
		stopAllMotors();

		//Drive back from stars
		while(LSensor>-150){
			Backwards();
			ArmUp();
		}
		SensorReset();
		stopAllMotors();

		//turn to fence
		while(Gyro<630){
			TurnRight();
		}
		SensorReset();
		stopAllMotors();

		//arm up and drive
		while(ArmSensor<2000){
			ArmUp();
			Forward();
		}
		SensorReset();
		stopAllMotors();

		Forward();
		wait(1.5);

		stopAllMotors();

		//open claw
		while(LClawSensor>1400){
			ClawOpen();
		}
		SensorReset();
		stopAllMotors();

		wait(0.5);

		while(LSensor>-400){
			Backwards();
		}
		SensorReset();
		stopAllMotors();

		while(ArmSensor>1950){
			ArmDown();
		}
		SensorReset();
		stopAllMotors();

		Forward();
		wait(1);
		stopAllMotors();

		while(ArmSensor<2000){
			ArmUp();
		}
		SensorReset();
		stopAllMotors();
	}

	//RIGHT CORNER
	if(Auto==5){

		//back
		while(LSensor>-100){
			Backwards();
		}
		SensorReset();
		stopAllMotors();

		//claw closeish
		while(LClawSensor<2000){
			ClawClose();
		}
		SensorReset();
		stopAllMotors();

		//arm down
		while(ArmSensor>0){
			ArmDown();
		}
		SensorReset();
		stopAllMotors();

		//Drive into stars
		while(LSensor<450){
			Forward();
		}
		SensorReset();
		stopAllMotors();

		//close claw
		while(LClawSensor<2900){
			ClawClose();
		}
		SensorReset();
		stopAllMotors();

		//Drive back from stars
		while(LSensor>-150){
			Backwards();
			ArmUp();
		}
		SensorReset();
		stopAllMotors();

		//turn to fence
		while(Gyro>-630){
			TurnLeft();
		}
		SensorReset();
		stopAllMotors();

		//arm up and drive
		while(ArmSensor<2000){
			ArmUp();
			Forward();
		}
		SensorReset();
		stopAllMotors();

		Forward();
		wait(1.5);

		stopAllMotors();

		//open claw
		while(LClawSensor>1400){
			ClawOpen();
		}
		SensorReset();
		stopAllMotors();

		wait(0.5);

		while(LSensor>-400){
			Backwards();
		}
		SensorReset();
		stopAllMotors();

		while(ArmSensor>1950){
			ArmDown();
		}
		SensorReset();
		stopAllMotors();

		Forward();
		wait(1);
		stopAllMotors();

		while(ArmSensor<2000){
			ArmUp();
		}
		SensorReset();
		stopAllMotors();
	}
	//LEFT CUBE

	if(Auto==6){

		//close claw
		while(LClawSensor<1350){
			ClawClose();
		}
		SensorReset();
		stopAllMotors();

		//arm down
		while(ArmSensor>0){
			ArmDown();
		}
		SensorReset();
		stopAllMotors();

		//into cube
		while(LSensor<1100){
			Forward();
		}
		SensorReset();
		stopAllMotors();

		//close claw
		while(LClawSensor<2600){
			ClawClose();
		}
		SensorReset();
		stopAllMotors();

		//turn to fence
		while(Gyro>-350){
			TurnLeft();
			ClawHold();
			ArmUp();
		}
		SensorReset();
		stopAllMotors();

		//up
		while(ArmSensor<1600){
			ArmUp();
			ClawHold();
		}
		SensorReset();
		stopAllMotors();

		//to fence
		Forward();
		ClawHold();
		wait(2);
		stopAllMotors();

		//start fence star knockdown
		while(LClawSensor>1400){
			ClawOpen();
		}
		SensorReset();
		stopAllMotors();

		wait(0.5);

		while(LSensor>-400){
			Backwards();
		}
		SensorReset();
		stopAllMotors();

		while(ArmSensor>1700){
			ArmDown();
		}
		SensorReset();
		stopAllMotors();

		Forward();
		wait(1);
		stopAllMotors();

		while(ArmSensor<2000){
			ArmUp();
		}
		SensorReset();
		stopAllMotors();
		//end fence star knockdown
	}

	//CUBE RIGHT
	if(Auto==7){

		//close claw
		while(LClawSensor<1050){
			ClawClose();
		}
		SensorReset();
		stopAllMotors();

		//arm down
		while(ArmSensor>0){
			ArmDown();
		}
		SensorReset();
		stopAllMotors();

		//into cube
		while(LSensor<1100){
			Forward();
		}
		SensorReset();
		stopAllMotors();

		//close claw
		while(LClawSensor<2600){
			ClawClose();
		}
		SensorReset();
		stopAllMotors();

		//turn to fence
		while(Gyro<350){
			TurnRight();
			ClawHold();
			ArmUp();
		}
		SensorReset();
		stopAllMotors();

		//up
		while(ArmSensor<1600){
			ArmUp();
			ClawHold();
		}
		SensorReset();
		stopAllMotors();

		//to fence
		Forward();
		ClawHold();
		wait(2);
		stopAllMotors();

		//start fence star knockdown
		while(LClawSensor>1400){
			ClawOpen();
		}
		SensorReset();
		stopAllMotors();

		wait(0.5);

		while(LSensor>-400){
			Backwards();
		}
		SensorReset();
		stopAllMotors();

		while(ArmSensor>1700){
			ArmDown();
		}
		SensorReset();
		stopAllMotors();

		Forward();
		wait(1);
		stopAllMotors();

		while(ArmSensor<2000){
			ArmUp();
		}
		SensorReset();
		stopAllMotors();
		//end fence star knockdown
	}
	*/
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	SensorReset();
	while (true)
	{
		SensorUpdate();

		if(vexRT[Btn8U]==1){
			SensorReset();
		}
		//Drive
		setMotor(FrontLeft, vexRT[Ch3Xmtr2]);
		setMotor(BackLeft, vexRT[Ch3Xmtr2]);
		setMotor(FrontRight, vexRT[Ch2Xmtr2]);
		setMotor(BackRight, vexRT[Ch2Xmtr2]);
		//Arm
		if(vexRT[Btn6UXmtr2]==1){
			setMotor(ArmLeft1,100);
			setMotor(ArmLeft2,100);
			setMotor(ArmRight1,100);
			setMotor(ArmRight2,100);
		}
		if(vexRT[Btn6DXmtr2]==1){
			setMotor(ArmLeft1,-100);
			setMotor(ArmLeft2,-100);
			setMotor(ArmRight1,-100);
			setMotor(ArmRight2,-100);
		}
		if(vexRT[Btn6DXmtr2]==0 && vexRT[Btn6UXmtr2]==0){
			setMotor(ArmLeft1,0);
			setMotor(ArmLeft2,0);
			setMotor(ArmRight1,0);
			setMotor(ArmRight2,0);
		}
		if(ArmSensor<130 && vexRT[Btn6UXmtr2]!=1){
			setMotor(ArmLeft1,-10);
			setMotor(ArmLeft2,-10);
			setMotor(ArmRight1,-10);
			setMotor(ArmRight2,-10);
		}

		//Claw
		setMultipleMotors(vexRT[Ch2],ClawLeft,ClawRight);
	}
}
