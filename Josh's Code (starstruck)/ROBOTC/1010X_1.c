#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in5,    gyro,           sensorNone)
#pragma config(Sensor, in6,    potarmR,        sensorPotentiometer)
#pragma config(Sensor, in7,    potarmL,        sensorPotentiometer)
#pragma config(Sensor, in8,    PEbatt,         sensorAnalog)
#pragma config(Sensor, dgtl1,  sArmLT,         sensorTouch)
#pragma config(Sensor, dgtl2,  sArmLB,         sensorTouch)
#pragma config(Sensor, dgtl3,  sArmRT,         sensorTouch)
#pragma config(Sensor, dgtl4,  sArmRB,         sensorTouch)
#pragma config(Sensor, dgtl5,  encoderR,       sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  encoderL,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, Enocderclaw,    sensorQuadEncoder)
#pragma config(Motor,  port1,           DriveBL,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           DriveFL,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           RollL,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           ArmLT,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           ArmLB,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           ArmRB,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           ArmRT,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           RollR,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           DriveFR,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          DriveBR,       tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"


int myauto = 1;

const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;


void autoselector(){
		clearLCDLine(0);
    clearLCDLine(1);
    bLCDBacklight = true;
		while(bIfiRobotDisabled){
			switch(myauto){
				case(1):
					displayLCDCenteredString(0, "Autonomous 1");
					displayLCDCenteredString(1, "1010X");
						if(nLCDButtons == leftButton){
							while(nLCDButtons != 0){}
							wait1Msec(5);
							myauto = 1;
							}
						else if(nLCDButtons == rightButton){
							while(nLCDButtons != 0){}
							wait1Msec(5);
							myauto = 2;
						}
						else{}
				break;
				case(2):
					displayLCDCenteredString(0, "Autonomous 2");
					displayLCDCenteredString(1, "1010X");

					if(nLCDButtons == leftButton){
						while(nLCDButtons != 0){}
						wait1Msec(5);
						myauto = 1;
						}
					else if(nLCDButtons == rightButton){
						while(nLCDButtons != 0){}
						wait1Msec(5);
						myauto = 3;
						}
					else{}
				break;
				case(3):
					displayLCDCenteredString(0, "Autonomous 3");
					displayLCDCenteredString(1, "1010X");

					if(nLCDButtons == leftButton){
						while(nLCDButtons != 0){}
						wait1Msec(5);
						myauto = 2;
						}
					else if(nLCDButtons == rightButton){
						while(nLCDButtons != 0){}
						wait1Msec(5);
						myauto = 4;
						}
					else{}
				break;
				case(4):
					displayLCDCenteredString(0, "Autonomous 4");
					displayLCDCenteredString(1, "1010X");

					if(nLCDButtons == leftButton){
						while(nLCDButtons != 0){}
						wait1Msec(5);
						myauto = 3;
						}
					else if(nLCDButtons == rightButton){
						while(nLCDButtons != 0){}
						wait1Msec(5);
						myauto = 4;
						}
					else{}
				break;

				break;

				default:
					myauto = 1;
				break;
				}
			}
}

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
bStopTasksBetweenModes = true;
bDisplayCompetitionStatusOnLcd = false;


	SensorType[in3] = sensorNone;
 	wait1Msec(1000);
 	SensorType[in3] = sensorGyro;
	wait1Msec(2000);//wait needed to calibrate

	autoselector();
}
/*---------------------------------------------------------------------------*/
/*                              Autonomous Task                              */
/*---------------------------------------------------------------------------*/
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void autorunrollers (int rollerpower){
	motor[RollL] = motor[RollR] = rollerpower;}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void autostoprollers(){
	motor[RollL] = motor[RollR] = 0;}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void autoopenrollers(){
		wait1Msec(10);
		motor[RollL] = motor[RollR] = -90;//backwards
		wait1Msec(350);
		motor[RollL] = motor[RollR] = 0;//stop for short period
		wait1Msec(80);
		motor[RollL] = motor[RollR] = 90;//forwards
		wait1Msec(500);
		motor[RollL] = motor[RollR] = 0;//stop for shortperiod
		wait1Msec(20);

}
///////////////////////////////////////////////
void autoarmliftsimpleup(int armpower1, int armheight1){


while (SensorValue[potarmR] <= armheight1){
	motor[ArmLB] =  motor[ArmLT] =	motor[ArmRB] =  motor[ArmRT] = armpower1;
}

motor[ArmLB] =  motor[ArmLT] = motor[ArmRB] =  motor[ArmRT] = 0;
	wait1Msec(10);
}

////////////////////////////////////////////////
void autoarmliftsimpledown(int armpower2, int armheight2){
	while (SensorValue[potarmR] >= armheight2){
	motor[ArmLB] =  motor[ArmLT] =	motor[ArmRB] =  motor[ArmRT] = armpower2;
}

motor[ArmLB] =  motor[ArmLT] = motor[ArmRB] =  motor[ArmRT] = 0;
	wait1Msec(10);
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void autoarmlift(int armpower, int armheight){ //negitive value for lowwering arm
	SensorValue[potarmL] = 0;
	SensorValue[potarmR] = 0;
			while (SensorValue[potarmL] <= armheight  && SensorValue[potarmR] <= armheight){
					if(SensorValue[potarmL] <= armheight){		//left
						motor[ArmLB] =  motor[ArmLT] = armpower;
					}else{
						motor[ArmLB] =  motor[ArmLT] = 0;}
					if (SensorValue[potarmR] <= armheight){			//right
						motor[ArmRB] =  motor[ArmRT] = armpower;
					}else{
						motor[ArmRB] =  motor[ArmRT] = 0;}
			}
	motor[ArmLB] =  motor[ArmLT] = motor[ArmRB] =  motor[ArmRT] = 0;
	wait1Msec(10);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void autodrivestraight (float kp, int distics, int timestep = 20){

	int totaltics = 0;
	int error = 0;
	int Rpower = 100;
	int Lpower = 100;

	SensorValue[encoderL] = 0;
	SensorValue[encoderR] = 0;

	while (distics >= totaltics){
		motor[DriveBL] = motor[DriveFL] = Lpower;
		motor[DriveBR] = motor[DriveFR] = Rpower;

		error = -SensorValue[encoderL] - SensorValue[encoderR];

		Lpower += -error * kp;//neg error for decrease when left side is too far

		Lpower = floor(Lpower);

		totaltics = (-SensorValue[encoderL] + SensorValue[encoderR])/2;

		//SensorValue[encoderL] = 0;
		//SensorValue[encoderR] = 0;
/*datalogDataGroupStart();

datalogAddValueWithTimeStamp(1, error);
datalogAddValueWithTimeStamp(2, Lpower);

datalogDataGroupEnd();
*/
		wait1Msec(timestep);
		}
	motor[DriveBL] = motor[DriveFL] = 0;
	motor[DriveBR] = motor[DriveFR] = 0;
	wait1Msec(10);
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void autogyroturnL(int powerturnL, int powerturnR, int gyrovalue){

SensorValue[gyro] = 0;
	while (SensorValue[gyro] >= gyrovalue){
		motor[DriveBL] = motor[DriveFL] = powerturnL;
		motor[DriveBR] = motor[DriveFR] = powerturnR;
	}
	motor[DriveBL] = motor[DriveFL] = motor[DriveBR] = motor[DriveFR] = 0;
	wait1Msec(10);}


void autogyroturnR(int powerturnL1, int powerturnR1, int gyrovalue){
	SensorValue[gyro] = 0;
		while (SensorValue[gyro] <= gyrovalue){
			motor[DriveBL] = motor[DriveFL] = powerturnL1;
			motor[DriveBR] = motor[DriveFR] = powerturnR1;
		}
		motor[DriveBL] = motor[DriveFL] = motor[DriveBR] = motor[DriveFR] = 0;
		wait1Msec(10);

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
task autonomous()
{
	clearLCDLine(0);
  clearLCDLine(1);
  bLCDBacklight = true;
  displayLCDCenteredString(0, "Let's Go!");

  //motor[DriveBL] = motor[DriveFL] = motor[DriveBR] = motor[DriveFR] = 127;
  //wait1Msec(2500);
  //motor[DriveBL] = motor[DriveFL] = motor[DriveBR] = motor[DriveFR] = 0;


	switch(myauto){
		case 1:
		//program: corner and along fence

		autoopenrollers();
		wait1Msec(10);

		autodrivestraight(0.25, 2075, 30);
		wait1Msec(100);
		autogyroturnL(-70, 70, -735);
		autoarmliftsimpleup(100, 2300);
		wait1Msec(80);
		autoarmliftsimpledown(-100, 1120);
		wait1Msec(80);
		autorunrollers(-127);
		autodrivestraight(0.08, 3700, 15);
		autostoprollers();

		break;

		case 2:
//go for middle cube
		autoopenrollers();
		wait1Msec(30);
		autogyroturnL(-100, 100, -400);//Power L, Power R, Gyro
		wait1Msec(100);
		autorunrollers(-127);
		autodrivestraight(10, 1000);//kp, ticks
		wait1Msec(1500);//wait to pick up cube
		autostoprollers();
		autoarmliftsimpleup(100, 2500);
		wait1Msec(150);
		autogyroturnR(100, 0, 550);
		wait1Msec(100);
		autodrivestraight(10, 800);
		autorunrollers(127);



		break;

		case 3:
		autoopenrollers();
		wait1Msec(30);
		autogyroturnR(100, -100, 450);//Power L, Power R, Gyro
		wait1Msec(100);
		autorunrollers(-127);
		autodrivestraight(10, 1000);//kp, ticks
		wait1Msec(1500);//wait to pick up cube
		autostoprollers();
		autoarmliftsimpleup(100, 2500);
		wait1Msec(150);
		autogyroturnL(0, 100, -550);
		wait1Msec(100);
		autodrivestraight(10, 800);
		autorunrollers(127);

		break;

		case 4:
		autoopenrollers();
		wait1Msec(10);

		autodrivestraight(0.25, 2075, 30);
		wait1Msec(100);
		autogyroturnR(70, -70, 800);
		autoarmliftsimpleup(100, 2300);
		wait1Msec(80);
		autoarmliftsimpledown(-100, 1120);
		wait1Msec(80);
		autorunrollers(-127);
		autodrivestraight(0.15, 3700, 15);
		autostoprollers();

		break;

		}
}

/*---------------------------------------------------------------------------*/
/*                              User Control Task                            */
/*---------------------------------------------------------------------------*/

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void driverollers (){
	if(vexRT[Btn5D] == 1 ){//out
  	motor[RollL] = 127;
 		motor[RollR] = 127;
 	}else if (vexRT[Btn5U] == 1){//in
 		motor[RollL] = -127;
 		motor[RollR] = -127;
 	}else{
 		motor[RollL] = 0;
 		motor[RollR] = 0;
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void drivebase () {
	motor[DriveBR] = motor[DriveFR] = vexRT[Ch2];//rightside
	motor[DriveBL] = motor[DriveFL] = vexRT[Ch3];//leftside
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void drivearm(){
	//leftside
if (SensorValue[sArmLB] == 1){
		if(vexRT[Btn6U] == 1){
				motor[ArmLB] =  motor[ArmLT] = 127;
		}else{
				motor[ArmLB] =  motor[ArmLT] = 0;
		}
	}else if (SensorValue[sArmLT] == 1){
		if(vexRT[Btn6D] == 1){
			motor[ArmLB] =  motor[ArmLT] = -127;
		}else{
			motor[ArmLB] =  motor[ArmLT] = 0;
		}
	}else {
		if(vexRT[Btn6U] == 1){
			motor[ArmLB] =  motor[ArmLT] = 127;
		}else if(vexRT[Btn6D] == 1){
			motor[ArmLB] =  motor[ArmLT] = -127;
		}else{
			motor[ArmLB] =  motor[ArmLT] = 0;}
	}

if (SensorValue[sArmRB] == 1){//rightup
	if(vexRT[Btn6U] == 1){
		motor[ArmRB] =  motor[ArmRT] = 127;
	}else{
		motor[ArmRB] =  motor[ArmRT] = 0;
	}
}
else if (SensorValue[sArmRT] == 1){
	if(vexRT[Btn6D] == 1){
		motor[ArmRB] =  motor[ArmRT] = -127;
	}else{
		motor[ArmRB] =  motor[ArmRT] = 0;
	}
}
else {
	if(vexRT[Btn6U] == 1){
		motor[ArmRB] =  motor[ArmRT] = 127;}
	else if(vexRT[Btn6D] == 1){
		motor[ArmRB] =  motor[ArmRT] = -127;}
	else{
		motor[ArmRB] =  motor[ArmRT] = 0;}
	}
}

/////////////////////////////////////////////////////////////////////// ,l;;-pojhhhjkoop00000]/////////////////////////////////////////

task usercontrol()
{
			bLCDBacklight = true;
			clearLCDLine(0);
			clearLCDLine(1);
  while (true)
		{
			displayLCDCenteredString(0, "Once more");
			displayLCDCenteredString(1, "into the fray");
			driverollers();
			drivebase();
			drivearm();

		}
}
